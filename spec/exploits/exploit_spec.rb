require 'spec_helper'
require 'ronin/exploits/exploit'

require 'helpers/exploits'
require 'helpers/payloads'

describe Exploits::Exploit do
  include Helpers

  let(:exploit) { load_exploit('simple') }

  it "should require a name attribute" do
    exp = described_class.new
    exp.should_not be_valid

    exp.name = 'test'
    exp.should be_valid
  end

  it "should have a unique name and version" do
    first_exp = described_class.create(
      :name => 'test2',
      :version => '0.0.1'
    )
    first_exp.should be_valid

    second_exp = described_class.new(
      :name => 'test2',
      :version => '0.0.1'
    )
    second_exp.should_not be_valid

    third_exp = described_class.new(
      :name => 'test2',
      :version => '0.0.2'
    )
    third_exp.should be_valid
  end

  describe "helpers" do
    it "should allow for the extending of Helper modules" do
      exploit.instance_eval { helper :padding }.should == true
    end

    it "should raise an UnknownHelper when extending an unknown helper" do
      lambda {
        exploit.instance_eval { helper :obvious_not_there }
      }.should raise_error(Exploits::UnknownHelper)
    end
  end

  describe "targets" do
    it "should have targeted Archs" do
      exploit.targeted_archs[0].name.should == 'x86'
      exploit.targeted_archs[1].name.should == 'x86-64'
    end

    it "should have targeted OSes" do
      exploit.targeted_oses[0].name.should == 'Linux'
      exploit.targeted_oses[0].version.should == '2.6.23'

      exploit.targeted_oses[1].name.should == 'Windows'
      exploit.targeted_oses[1].version.should == '7.1'
    end

    it "should have targeted software" do
      exploit.targeted_software[0].name.should == 'ExampleWare'
      exploit.targeted_software[0].version.should == '1.5'
    end

    it "should allow the selection of a target by index" do
      exploit.use_target!(1)

      exploit.target.arch.name.should == 'x86-64'
    end

    it "should allow the selection of a target that matches a block" do
      exploit.use_target! { |target| target.arch.name == 'x86-64' }

      exploit.target.arch.name.should == 'x86-64'
    end

    it "should select the first target if nothing is passed to use_target!" do
      exploit.use_target!()

      exploit.target.arch.name.should == 'x86'
    end

    it "should have a default target" do
      exploit.target.should_not be_nil

      exploit.target.arch.name.should == 'x86'

      exploit.target.os.name.should == 'Linux'
      exploit.target.os.version.should == '2.6.23'
    end

    it "should have a default targeted Arch" do
      exploit.arch.name.should == 'x86'
    end

    it "should have a default targeted OS" do
      exploit.os.name.should == 'Linux'
      exploit.os.version.should == '2.6.23'
    end

    it "should have a default targeted Software" do
      exploit.software.name.should == 'ExampleWare'
      exploit.software.version.should == '1.5'
    end
  end

  describe "payload" do
    let(:payload) { load_payload('simple') }

    it "should set the payloads exploit when setting the payload" do
      payload.exploit.should be_nil

      exploit.payload = payload
      payload.exploit.should == exploit
    end

    it "should be able to set the payload to nil" do
      exploit.payload = payload
      exploit.payload = nil

      exploit.payload.should be_nil
    end

    it "should set the payload and the exploit of the payload to nil" do
      exploit.payload = payload
      exploit.payload = nil

      payload.exploit.should be_nil
    end

    it "should leverage the same resources that the payload leverages" do
      exploit.payload = payload

      exploit.should be_leverages(:fs)
    end

    describe "raw payload" do
      it "should build a raw payload" do
        exploit.payload = payload
        exploit.build_payload!

        exploit.raw_payload.should == 'code.func'
      end

      it "should pass options to the payload when building the raw payload" do
        exploit.payload = payload
        exploit.build_payload!(:custom => 'test')

        exploit.raw_payload.should == 'code.test'
      end

      it "should default raw_payload to an empty String, if payload is nil" do
        exploit.payload = nil
        exploit.build_payload!

        exploit.raw_payload.should == ''
      end

      it "should not reset raw_payload, if payload is nil" do
        exploit.payload = nil
        exploit.raw_payload = 'data'

        exploit.build_payload!
        exploit.raw_payload.should == 'data'
      end
    end

    describe "encoding" do
      it "should have no payload encoders by default" do
        exploit.encoders.should be_empty
      end

      it "should accept blocks as payload encoders" do
        exploit.raw_payload = 'data'

        exploit.encode_payload do |payload|
          payload.capitalize
        end

        exploit.encode_payload!
        exploit.encoded_payload.should == 'Data'
      end

      it "should accept an object with an #encode method" do
        exploit.raw_payload = 'data'
        exploit.encode_payload(Encoders::Encoder.new)

        exploit.encode_payload!
        exploit.encoded_payload.should == 'data'
      end

      it "should not accept objects without an #encode method" do
        lambda {
          exploit.encode_payload(Object.new)
        }.should raise_error(RuntimeError)
      end

      it "should accept either a payload encoder object or a block" do
        lambda {
          exploit.encode_payload()
        }.should raise_error(ArgumentError)
      end

      it "should encode a String payload" do
        exploit.raw_payload = 'data'

        exploit.encode_payload!
        exploit.encoded_payload.should == 'data'
      end

      it "should encode a String using encoders" do
        exploit.raw_payload = 'data'
        exploit.encoders << lambda { |payload| payload.upcase }

        exploit.encode_payload!
        exploit.encoded_payload.should == 'DATA'
      end

      it "should ignore payload encoders which return nil" do
        exploit.raw_payload = 'data'
        exploit.encoders << lambda { |payload| nil }

        exploit.encode_payload!
        exploit.encoded_payload.should == 'data'
      end
    end

    it "should deploy the payload after deploying the exploit" do
      exploit.payload = payload
      payload.should_not be_deployed

      exploit.build!
      exploit.deploy! do
        exploit.payload.should be_deployed
      end
    end

    it "should pass missing methods to the payload" do
      exploit.payload = payload
      exploit.some_method.should == :some_result
    end
  end

  describe "#exploit!" do
    it "should build and deploy the exploit when exploited" do
      exploit.exploit!

      exploit.should be_built
      exploit.should be_deployed
    end

    it "should not deploy during a dry-run of the exploit" do
      exploit.exploit!(:dry_run => true)

      exploit.should be_built
      exploit.should_not be_deployed
    end
  end
end
